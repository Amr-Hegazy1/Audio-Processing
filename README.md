
## Signals and Systems Theory

## Team Members:
<a href="https://github.com/Omar-Orensa"><img src="https://avatars.githubusercontent.com/u/131605903?v=4" style="width:20%;"/></a>
<a href="https://github.com/Amr-Hegazy1"><img src="https://avatars.githubusercontent.com/u/68474553?v=4" style="width:20%;"/></a>

## (COMM 401 )

## Lab Project (PIANO)

## Audio Processing



# Project Description

- This project is classified into 2 milestones:
Milestone 1 :You are the PIANIST,you should mix and match frequencies to
generate your own song.

Milestone 2 :Noise Cancellation and Frequency Domain (will be posted
later after the midterms).




# Background

- Single tone generation:
Each pressed piano key/note number 𝑖, corresponds to a single tone with
frequency 𝑓𝑖 generated for a certain period of time𝑇𝑖starting from time 𝑡𝑖 over a
defined time range 𝑡.

```
𝑥𝑖 𝑡 = sin 2 𝜋𝑓𝑖𝑡 [𝑢(𝑡−𝑡𝑖)−𝑢(𝑡−𝑡𝑖−𝑇𝑖)]
```
Where the unit step functions defines the playing interval.

Example: Assume that we started pressing the middle Ckey (𝑓 1 = 261. 63 𝐻𝑧),
at time 𝑡 1 = 0 for a duration of 𝑇 1 = 1. 5 seconds, the resultant signal is:

```
𝑥 1 𝑡 = sin 2 ∗ 261. 63 𝜋𝑡 [𝑢(𝑡)−𝑢(𝑡− 0. 5 )]
```
```
0 1.5 3
```
```
𝑥 1 𝑡
```

# Milestone 1 : The Pianist

- Signal/Song Generation:
Generate your own signal using 𝑁 pairs of notes chosen from the 3 rdand
4 thpiano octaves assuming that you are playing will both hands at the same
time ( 3 rdoctave with the left hand/ 4 thoctave with right hand),

Each piano key/note frequency is given below. Your final song could be
generated as follows,

```
𝑥 𝑡 = ෍
𝑖= 1
```
```
𝑁
[sin 2 𝜋Ϝ𝑖𝑡 +sin 2 𝜋𝑓𝑖𝑡 ][𝑢(𝑡−𝑡𝑖)−𝑢(𝑡−𝑡𝑖−𝑇𝑖)]
```
```
Chosen from the 3 rdoctave Chosen from the 4 thoctave
```

# Milestone 1 : The Pianist

```
1 ) You will need to import the following libraries.
import numpy as np
import matplotlib.pyplot as plt
import sounddevice as sd
```
```
2 ) Set the total song playing time to 3 seconds starting from 0 for 12 × 1024
samples.
𝑡 =np.linspace( 0 , 3 , 12 ∗ 1024 )
```
```
3 ) Customize your own song by setting the number of pairs of notes 𝑁.For
each pair number 𝑖, set the left hand frequency Ϝ𝑖, right hand frequency 𝑓𝑖,
the pressing starting time 𝑡𝑖, and how long you will press both keys 𝑇𝑖.
N.B you can freely customize these values to play the song you want.
If you want to play with one hand only, you can set the frequency of the other hand to 0.
```
- Procedure:


# Milestone 1 : The Pianist

```
4 ) Define your signal/song using the previous parameters:
```
```
5 ) Plot your signal/song in the time domain your output will look similar to
the following: plt.plot(t, x)
```
```
NB. The time separation between the notes will vary from one group to another according to your
song. We also can’t notice the variations in the sinusoidal tones due to the high frequencies.
```
```
6 ) Finally:Play your song using:
sd.play(x, 3 ∗ 1024 )
```


## Lab Project (PIANO)-Milestone 2

## Noise Cancelation

Faculty of Information Engineering and Technology
Department of Communication Engineering


# Background

- Noise generation:
Assume that additional noise is generated by a child who kept pressing the
same 2 random piano keys during your song playing interval such that the
noise is represented as follows,

Where, 𝑓𝑛 1 and 𝑓𝑛 2 are two frequencies selected randomly from the 3rdand 4th

octaves frequencies list respectively. Your final song after the noise becomes,

#### 𝑥𝑛 𝑡 =𝑥 𝑡 +𝑛(𝑡)

Goal: Noise Cancelation: using frequency domain conversion

```
𝑛 𝑡 =sin 2 𝑓𝑛 1 𝜋𝑡 +sin 2 𝑓𝑛 2 𝜋𝑡
```

# Milestone 2: Frequency Conversion

```
0) You will need to add this line at the beginning of your code:
```
```
from scipy.fftpackimport fft
```
```
1) Set the number of samples 𝑁 to 𝑦𝑜𝑢𝑟_𝑠𝑜𝑛𝑔_𝑑𝑢𝑟𝑎𝑡𝑖𝑜𝑛x 1024. Then set
the frequency axis range to,
```
```
𝑁 = 3 x 1024
𝑓= np.linspace( 0 , 512 ,int(𝑁/ 2 ))
```
```
2) Convert the time signal 𝑥(𝑡)to the frequency signal 𝑋(𝑓) from,
```
### x_f = fft(x)

### x_f = 2/N * np.abs(x_f[0:np.int(N/2)])

```
Your final output will look as following,
```
- Procedure:


# Milestone 2: Noise Generation

- Procedure:

```
3) Generate the noise signal as described in slide 3 where the two random
frequencies are selected as follows,
```
### 𝑓𝑛 1 & 𝑓𝑛 2 = np.random.randint( 0 , 512 , 2 )

```
Hint: Each time you run the code you will get different noise.
```
```
4) Add the generated noise 𝑛(𝑡) to the signal 𝑥 𝑡 ,
𝑥𝑛 𝑡 = 𝑥 𝑡 +𝑛(𝑡)
```
```
Hint: Play the new signal to notice the noise effect on the sound.
```
```
5) Convert the noise contaminated signal 𝑥𝑛 𝑡 to the signal 𝑋𝑛 𝑓 in
frequency domain, it looks as follows,
```
```
Hint: You will notice that the signal contains two very high frequency peaks
```

# Milestone 2: Noise Cancelation

- Procedure:
    6) Find the two random noise frequencies:by finding the frequency indices
       that corresponds to the peaks of the signal 𝑋𝑛 𝑓 which is higher than
       the maximum peak of the original signal 𝑋 𝑓 without noise rounded to
       the next integer (to avoid including the maximum value due to double precision errors).

```
7) Round the frequency values at that indices in 𝑓 to get 𝑓መ𝑛 1 and 𝑓መ𝑛 2 (since
we generate random integer values of frequencies)
```
```
8) Filter the noise by subtracting two tones with the two found frequencies
```
```
𝑥𝑓𝑖𝑙𝑡𝑒𝑟𝑒𝑑 𝑡 =𝑥𝑛 𝑡 −[sin 2 𝑓𝑛 1 𝜋𝑡 +sin 2 𝑓𝑛 2 𝜋𝑡 ]
```
```
9) Play the filtered signal to make sure that you get the same original sound
without noise
sd.play(𝑥𝑓𝑖𝑙𝑡𝑒𝑟𝑒𝑑, 4 ∗ 1024 )
```


